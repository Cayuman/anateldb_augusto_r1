# AUTOGENERATED! DO NOT EDIT! File to edit: ..\nbs\merging.ipynb.

# %% auto 0
__all__ = ['MAX_DIST', 'COLS', 'check_add_row', 'get_subsets', 'merge_closer', 'merge_single', 'merge_triple', 'check_merging',
           'get_frequencies_set', 'merge_aero']

# %% ..\nbs\merging.ipynb 2
from decimal import Decimal
from itertools import product
import pandas as pd
from geopy.distance import geodesic

from .constants import ENTIDADES
from .format import input_coordenates, scrape_dataframe, df_optimize
from .reading import read_icao, read_aisw, read_aisg, read_aero, read_base
MAX_DIST = 0.5 #Km
COLS = ['Frequency', 'Latitude', 'Longitude', 'Description']

# %% ..\nbs\merging.ipynb 4
def check_add_row(df, # DataFrame para mesclar adicionar o registro
                  f, # Frequência (MHz) em análise do registro 
                  rows, # Lista de registros para mesclar
                  dicts, # Dicionário fonte dos registros
):
    """Mescla os registros em `rows` de frequência `f` e os adiciona como uma linha do DataFrame `df`
    Os registros em `rows` somente são mesclados se ainda constarem nos dicionários fonte `dicts`
    Após a mesclagem, os registros são removidos dos dicionários fonte `dicts`   
    """
    if all(row.Index in dict for row, dict in zip(rows, dicts)):
        lat = sum(row.Latitude for row in rows) / len(rows)
        long = sum(row.Longitude for row in rows) / len(rows)
        desc = ' | '.join(row.Description for row in rows)
        d = {'Frequency': f, 'Latitude': lat, 'Longitude': long, 'Description': desc}
        for row, dict in zip(rows, dicts):
            dict.pop(row.Index)
        return pd.concat([df, pd.DataFrame(d, index=[0])], ignore_index=True)
    return df


# %% ..\nbs\merging.ipynb 5
def get_subsets(f, # Frequência (MHz) em análise do registro
                *dfs, # Conjunto de DataFrames a serem analisados
):
    """Retorna os subconjuntos de registros de frequência `f` em cada dataframe `dfs`
    Os subconjuntos são retornados em forma de dicionário, onde a chave é o índice do registro
    """
    return [{s.Index: s for s in df.loc[df.Frequency == f, COLS].itertuples()} for df in dfs]


# %% ..\nbs\merging.ipynb 6
def merge_closer(frequencies, # Lista de frequências em comum
                 df, # DataFrame de saída
                 df_left, # DataFrame 1 de entrada da esquerda
                 df_right # DataFrame 2 de entrada da direita
):
    """Mescla os registros de frequência `frequencies` de `df_left` e `df_right` em `df`
    Essa função é utilizada para mesclar registros que possuem frequências em comum listadas em `frequencies`
    Os registros são mesclados se a distância entre eles for menor que `MAX_DIST`
    do contrário são adicionados individualmente como uma linha no DataFrame de saída `df`	
    """
    for f in frequencies:
        sa, sb = get_subsets(f, df_left, df_right)
        if all([sa, sb]): # Somente há registros para mesclar se estiverem nos dois conjuntos
            for fa, fb in list(product(sa.copy().values(), sb.copy().values())):
                if geodesic((fa.Latitude, fa.Longitude), (fb.Latitude, fb.Longitude)).km <= MAX_DIST:
                    df = check_add_row(df, f, [fa, fb], [sa, sb]) 
        for reg in [sa, sb]: # Do contrário os registros são adicionados individualmente ao DataFrame
            for r in reg.copy().values():
                df = check_add_row(df, f, [r], [reg])
    return df


# %% ..\nbs\merging.ipynb 7
def merge_single(frequencies, # Lista de frequências em comum
                 df, # DataFrame de saída
                 df_left # DataFrame de entrada
):
    """Mescla os registros de frequência `frequencies` de `df_left` em `df`"""
    for f in frequencies:
        if sa := get_subsets(f, df_left)[0]:
            for fa in sa.copy().values():
                df = check_add_row(df, f, [fa], [sa])
    return df

# %% ..\nbs\merging.ipynb 8
def merge_triple(frequencies, # Lista de frequências em comum
                 df, # DataFrame de saída 
                 df_left, # DataFrame 1 de entrada
                 df_middle, # DataFrame 2 de entrada 
                 df_right, # DataFrame 3 de entrada 
):
    """Mescla os registros de frequência `frequencies` de `df_left`, `df_middle` e `df_right` em `df`
    Essa função é utilizada para mesclar registros que possuem frequências em comum listadas em `frequencies`
    Os registros são mesclados se a distância entre eles for menor que `MAX_DIST`
    do contrário são adicionados individualmente como uma linha no DataFrame de saída `df`
    """
    for f in frequencies:
        sa, sb, sc = get_subsets(f, df_left, df_middle, df_right)
        if all([sa, sb, sc]):
            for fa, fb, fc in list(product(sa.copy().values(), sb.copy().values(), sc.copy().values())):
                dab = geodesic((fa.Latitude, fa.Longitude), (fb.Latitude, fb.Longitude)).km
                dac = geodesic((fa.Latitude, fa.Longitude), (fc.Latitude, fc.Longitude)).km
                dbc = geodesic((fb.Latitude, fb.Longitude), (fc.Latitude, fc.Longitude)).km
                if all(d <= MAX_DIST  for d in [dab, dac, dbc]):
                    df = check_add_row(df, f, [fa, fb, fc], [sa, sb, sc])
                elif all(d > MAX_DIST  for d in [dac, dbc]):
                    df = check_add_row(df, f, [fa, fb], [sa, sb])
                elif all(d > MAX_DIST  for d in [dab, dac]):
                    df = check_add_row(df, f, [fa, fc], [sb, sc])
                elif all(d > MAX_DIST for d in [dab, dbc]):
                    df = check_add_row(df, f, [fa, fc], [sa, sc])
        for reg in [sa, sb, sc]:
            for r in reg.copy().values():
                df = check_add_row(df, f, [r], [reg])        
    return df

# %% ..\nbs\merging.ipynb 9
def check_merging(df, # DataFrame de saída
                  icao, # DataFrame fonte 1
                  aisw, # DataFrame fonte 2 
                  aisg, # DataFrame fonte 3
):
    """Verifica a validade da mesclagem dos registros de `icao`, `aisw` e `aisg` em `df`"""
    three_merges = df[df.Description.str.contains('\|.*\|')]
    two_merges = df[(df.Description.str.contains('[\|]{1}')) & (~df.index.isin(three_merges.index))]
    no_merge = df[~df.Description.str.contains('[\|]{1}')]
    return len(no_merge) + len(two_merges) * 2 + len(three_merges) * 3 == len(icao) + len(aisw) + len(aisg)


# %% ..\nbs\merging.ipynb 10
def get_frequencies_set(df1, df2, df3):
    """Retorna todos os conjuntos de frequências do Diagrama de Venn entre os registros de `df1`, `df2` e `df3`"""
    f1 = set(df1.Frequency.tolist())
    f2 = set(df2.Frequency.tolist())
    f3 = set(df3.Frequency.tolist())
    ABC = f1.intersection(f2).intersection(f3)
    AB = f1.intersection(f2).difference(ABC)
    BC = f2.intersection(f3).difference(ABC)
    AC = f1.intersection(f3).difference(ABC)
    A = f1.difference(ABC).difference(AB).difference(AC)
    B = f2.difference(ABC).difference(AB).difference(BC)
    C = f3.difference(ABC).difference(BC).difference(AC)
    return A, B, C, AB, AC, BC, ABC

# %% ..\nbs\merging.ipynb 11
def merge_aero(folder, # Pasta onde estão os arquivos de entrada
):
    """Mescla os registros de mesma frequência e próximos dos arquivos da aeronáutica em `folder`"""
    icao = read_icao(folder).drop(columns=['Service', 'Station'])
    aisw = read_aisw(folder).drop(columns=['Service', 'Station'])
    aisg = read_aisg(folder).drop(columns=['Service', 'Station'])
    df = pd.DataFrame(columns=['Frequency', 'Latitude', 'Longitude', 'Description'])
    A, B, C, AB, AC, BC, ABC = get_frequencies_set(icao, aisw, aisg)
    df = merge_closer(AB, df, icao, aisw)
    df = merge_closer(AC, df, icao, aisg)
    df = merge_closer(BC, df, aisw, aisg)
    df = merge_single(A, df, icao)
    df = merge_single(B, df, aisw)
    df = merge_single(C, df, aisg)
    df = merge_triple(ABC, df, icao, aisw, aisg)
    if not check_merging(df, icao, aisw, aisg):
        raise ValueError("Divergência na contagem de linhas entre as bases individuais e a combinação")
    return df

