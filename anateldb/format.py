# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/format.ipynb (unless otherwise specified).

__all__ = ['row2dict', 'dict2cols', 'parse_plano_basico', 'scrape_dataframe', 'input_coordenates', 'parse_bw',
           'optimize_floats', 'optimize_ints', 'optimize_objects', 'df_optimize', 'format_types']

# Cell
import re
from typing import List, Iterable, Union
from pathlib import Path
from collections import OrderedDict
from decimal import Decimal

import pandas as pd
from unidecode import unidecode
from gazpacho import get, Soup
import requests
from fastcore.utils import listify
from rich.progress import track

from .constants import ENTIDADES, COL_PB, ESTACAO, BW, BW_pattern

# Cell
def row2dict(row: dict) -> dict:  # sourcery skip: identity-comprehension
    """Receives a json row and return the dictionary from it"""
    return dict(row.items())


def dict2cols(df: pd.DataFrame, reject: Iterable[str] = ()) -> pd.DataFrame:
    """Recebe um dataframe com dicionários nas células e extrai os dicionários como colunas
    Opcionalmente ignora e exclue as colunas em reject
    """
    for column in df.columns:
        if column in reject:
            df.drop(column, axis=1, inplace=True)
            continue
        if type(df[column].iloc[0]) == OrderedDict:
            try:
                new_df = pd.DataFrame(df[column].apply(row2dict).tolist())
                df = pd.concat([df, new_df], axis=1)
                df.drop(column, axis=1, inplace=True)
            except AttributeError:
                continue
    return df


def parse_plano_basico(row: dict, cols: Iterable[str] = COL_PB) -> dict:
    """Receives a json row and filter the column in `cols`"""
    return {k: row[k] for k in cols}


def scrape_dataframe(id_list: Iterable[str]) -> pd.DataFrame:
    """Receives a list of ids and returns a dataframe with the data from web scraping the MOSAICO page"""
    df = pd.DataFrame()
    for id_ in track(id_list, description="Baixando informações complementares da Web"):
        html = get(ESTACAO.format(id_))
        df = df.append(
            pd.read_html(Soup(getattr(html, "text", "")).find("table").html)[0]
        )

    df.rename(
        columns={"NumFistel": "Fistel", "Num Serviço": "Num_Serviço"}, inplace=True
    )
    return df[
        [
            "Status",
            "Entidade",
            "Fistel",
            "Frequência",
            "Classe",
            "Num_Serviço",
            "Município",
            "UF",
        ]
    ]

# Cell
def input_coordenates(df: pd.DataFrame, pasta: Union[str, Path]) -> pd.DataFrame:
    """Input the NA's in Coordinates with those of the cities"""
    municipios = Path(f"{pasta}/municípios.fth")
    if not municipios.exists():
        municipios = Path(f"{pasta}/municípios.xlsx")
        if not municipios.exists():
            raise FileNotFoundError(
                f"É necessario a tabela de municípios municípios.fth | municípios.xlsx na pasta {pasta}"
            )
        m = pd.read_excel(municipios, engine="openpyxl")
    else:
        m = pd.read_feather(municipios)
    m.loc[
        m.Município == "Sant'Ana do Livramento", "Município"
    ] = "Santana do Livramento"
    m["Município"] = m.Município.apply(unidecode).str.lower().str.replace("'", " ")
    m["UF"] = m.UF.str.lower()
    df["Coordenadas_do_Município"] = False
    df["Latitude"] = df.Latitude.str.replace(",", ".")
    df["Longitude"] = df.Longitude.str.replace(",", ".")
    df.loc[df["Município"] == "Poxoréo", "Município"] = "Poxoréu"
    df.loc[df["Município"] == "Couto de Magalhães", "Município"] = "Couto Magalhães"
    df["Município"] = df.Município.astype("string")
    criteria = (
        (df.Latitude == "")
        | (df.Latitude.isna())
        | (df.Longitude == "")
        | (df.Longitude.isna())
    ) & df.Município.isna()
    df = df[~criteria]
    for row in df[
        (
            (df.Latitude == "")
            | (df.Latitude.isna())
            | (df.Longitude == "")
            | (df.Longitude.isna())
        )
    ].itertuples():
        try:
            left = unidecode(row.Município).lower()
            m_coord = (
                m.loc[
                    (m.Município == left) & (m.UF == row.UF.lower()),
                    ["Latitude", "Longitude"],
                ]
                .values.flatten()
                .tolist()
            )
            df.loc[row.Index, "Latitude"] = m_coord[0]
            df.loc[row.Index, "Longitude"] = m_coord[1]
            df.loc[row.Index, "Coordenadas_do_Município"] = True
        except ValueError:
            print(left, row.UF, m_coord)
            continue
    return df


def parse_bw(bw: str) -> float:
    """Parse the bandwidth string"""
    if match := re.match(BW_pattern, bw):
        multiplier = BW[match.group(2)]
        if mantissa := match.group(3):
            number = float(f"{match.group(1)}.{mantissa}")
        else:
            number = float(match.group(1))
        return multiplier * number
    return -1

# Cell
def optimize_floats(df: pd.DataFrame, exclude: Iterable[str] = None) -> pd.DataFrame:
    """Optimize the floats in the dataframe to reduce the memory usage"""
    floats = df.select_dtypes(include=["float64"]).columns.tolist()
    floats = [c for c in floats if c not in listify(exclude)]
    df[floats] = df[floats].apply(pd.to_numeric, downcast="float")
    return df


def optimize_ints(df: pd.DataFrame, exclude: Iterable[str] = None) -> pd.DataFrame:
    """Optimize the ints in the dataframe to reduce the memory usage"""
    ints = df.select_dtypes(include=["int64"]).columns.tolist()
    ints = [c for c in ints if c not in listify(exclude)]
    df[ints] = df[ints].apply(pd.to_numeric, downcast="integer")
    return df


def optimize_objects(
    df: pd.DataFrame,
    datetime_features: Iterable[str] = None,
    exclude: Iterable[str] = None,
) -> pd.DataFrame:
    """Optimize the objects in the dataframe to category | string to reduce the memory usage"""
    exclude = listify(exclude)
    datetime_features = listify(datetime_features)
    for col in df.select_dtypes(
        include=["object", "string", "category"]
    ).columns.tolist():
        if col not in datetime_features:
            if col in exclude:
                continue
            num_unique_values = len(df[col].unique())
            num_total_values = len(df[col])
            if float(num_unique_values) / num_total_values < 0.5:
                dtype = "category"
            else:
                dtype = "string"
            df[col] = df[col].astype(dtype)
        else:
            df[col] = pd.to_datetime(df[col]).dt.date
    return df


def df_optimize(
    df: pd.DataFrame,
    datetime_features: Iterable[str] = None,
    exclude: Iterable[str] = None,
):
    """Optimize the data types in dataframe to reduce the memory usage"""
    if datetime_features is None:
        datetime_features = []
    return optimize_floats(
        optimize_ints(optimize_objects(df, datetime_features, exclude), exclude),
        exclude,
    )

# Cell
def format_types(df: pd.DataFrame, # raw DataFrame to format
                 stem: str = None # identifier for format specific conversions
                ) -> pd.DataFrame: # DataFrame with optimized types

    """Convert the columns of a dataframe to optimized types"""
    df["Frequência"] = df["Frequência"].astype("float")
    df["Latitude"] = df["Latitude"].astype("float32")
    df["Longitude"] = df["Longitude"].astype("float32")
    df["Entidade"] = df["Entidade"].astype("string")
    df["Fistel"] = df["Fistel"].astype("string")
    df["Município"] = df["Município"].astype("category")
    df["UF"] = df["UF"].astype("category")
    df["CNPJ"] = df["CNPJ"].astype("string")
    df["Número_Estação"] = df["Número_Estação"].astype("string")
    df["Num_Serviço"] = df["Num_Serviço"].astype("category")
    if stem == "stel":
        df.loc[:, "Validade_RF"] = df.Validade_RF.astype("string").str.slice(0, 10)
        df.loc[df.Unidade == "kHz", "Frequência"] = df.loc[
            df.Unidade == "kHz", "Frequência"
        ].apply(lambda x: Decimal(x) / Decimal(1000))
        df.loc[df.Unidade == "GHz", "Frequência"] = df.loc[
            df.Unidade == "GHz", "Frequência"
        ].apply(lambda x: Decimal(x) * Decimal(1000))
        df.drop("Unidade", axis=1, inplace=True)
    elif stem == "radcom":
        a = df.Situação.isna()
        df.loc[a, "Classe"] = df.loc[a, "Fase"]
        df.loc[~a, "Classe"] = (
            df.loc[~a, "Fase"].astype("string")
            + "-"
            + df.loc[~a, "Situação"].astype("string")
        )
        df.loc[:, "Classe"] = df["Classe"].astype("category")
        df.drop(["Fase", "Situação"], axis=1, inplace=True)
    return optimize_objects(df)
